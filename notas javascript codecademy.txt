JAVASCRIPT CODECADEMY:

-----LECCION 1-----
COMENTARIO EN UNA LINEA: // blablablabla
COMENTARIO EN VARIAS LINEAS: /* blablabla
				blabla */
TIPOS DE DATA PRIMITIVOS:
NUMBER: 4, 8, 1516, 23.44
STRING: 'blablalba', "blablabla"
BOOLEAN: true, false (on and off switch)
NULL: Null (intentional absence of a value)
UNDEFINED: Undefined (parecido a null)
SYMBOL

IMPRIMIR ALGO:
console.log(7); // Imprime 7
console.log('Hola!'); // Imprime Hola!
console.log(3 + 4); // Imprime 7 (es una operacion suma)
console.log('hi' + 'ya'); // Prints 'hiya'
console.log('Hello'.length); // Prints 5

METODOS:
'example string'.methodName()
When we use console.log() we’re calling the .log() method on the console object. 
EJS:
console.log('hello'.toUpperCase()); // Prints 'HELLO'
console.log('Hey'.startsWith('H')); // Prints true

Built-in Objects:
if you want to perform more complex mathematical operations than arithmetic, 
JavaScript has the built-in Math object.
Ej:
console.log(Math.random()); // Prints a random number between 0 and 1
console.log(Math.random() * 50); // Prints a random number between 0 and 1 multiplied by 50
console.log(Math.floor(Math.random() * 50)); // Prints the number  rounded down to the 
nearest whole number.

-----LECCION 2-----
VARIABLES: They label and store data in memory
What to do with them: 1) Create a variable with a descriptive name.
		      2) Store or update information stored in a variable.		
		      3) Reference or “get” information stored in a variable.
Ej: 	var myName = 'Arya';
	console.log(myName);  // Output: Arya

let: the variable CAN be reassigned a different value

Ej:  	let meal = 'Enchiladas';
	console.log(meal); // Output: Enchiladas
	meal = 'Burrito';
	console.log(meal); // Output: Burrito

	let price;
	console.log(price); // Output: undefined
	price = 350;
	console.log(price); // Output: 350

const: the variable CAN'T be reassigned a different value

Ejs escritura matematica con variables: (+=, -=, *=, /=, ++, --)
	let w = 4;
	w += 1; // Can be written as w = w + 1

	let x = 20;
	x -= 5; // Can be written as x = x - 5

	let y = 50;
	y *= 2; // Can be written as y = y * 2

	let z = 8;
	z /= 2; // Can be written as z = z / 2
	
	let a = 10;
	a++;
	console.log(a); // Output: 11

	let b = 20;
	b--;
	console.log(b); // Output: 19

Ej operacion con variable:
	let myPet = 'armadillo';
	console.log('I own a pet ' + myPet + '.'); // Output: 'I own a pet armadillo.'

INTERPOLACION:
	const myPet = 'armadillo';
	console.log(`I own a pet ${myPet}.`); // Output: I own a pet armadillo.

TYPEOF: me dice qué tipo de data tiene la variable
	const unknown1 = 'foo';
	console.log(typeof unknown1); // Output: string

-----LECCION 3-----
CONDICIONALES:
	if (true) {
  	  console.log('This message will print!'); 
	}        // Prints "This message will print!"

COMPARADORES: <: Less than
	      >: Greater than
	      <=: Less than or equal to
	      >=: Greater than or equal to
	      ===: Is equal to
	      !==: Is NOT equal to

OPERADORES LOGICOS:
	      &&: and
	      ||: or
	      !: not
TUTHY AND FALSY:
let myVariable = 'blablabla'; (truthy)
let myVariable = 0, "", '', null, undefined, NaN; (falsy)
EJ:
	let numberOfApples = 0;
	if (numberOfApples){
   	  console.log('Let us eat apples!');
	} else {
   	  console.log('No apples left!');
	}  // Prints 'No apples left!'

let defaultName = username (truthy) || 'Stranger' (falsy);

TERNARY: ternary operators can be used for conditions which evaluate to true or false.
EJ:
let isNightTime = true;
                                       |
if (isNightTime) {                     |
  console.log('Turn on the lights!');  |  =  isNightTime ? console.log('Turn on the lights!') : console.log('Turn off the lights!');
} else {                               |
  console.log('Turn off the lights!'); |
}                                      

SWITCH: ECONOMIZA LA GRAMATICA DE MUCHOS ELSE IF
EJ:

let groceryItem = 'papaya';

if (groceryItem === 'tomato') {		|	switch (groceryItem) {
  console.log('Tomatoes are $0.49');	|	  case 'tomato':
} else if (groceryItem === 'papaya'){	|  =  	    console.log('Tomatoes are $0.49');
  console.log('Papayas are $1.29');	|	    break;
} else {				|	  case 'lime':
  console.log('Invalid item');		|	    console.log('Limes are $1.49');
}						    break;
						  case 'papaya':
						    console.log('Papayas are $1.29');
						    break;
						  default:
						    console.log('Invalid item');
						    break;
						}

-----LECCION 4-----
FUNCIONES:
function getReminder() {
  console.log('Water the plants.');
}
AHI ARRIBA SOLO ESTOY DECLARANDO LA FUNCION. PARA VERLA NECESITO NOMBRARLA ENTONCES
PONGO ESTO:
getReminder();

PARAMETROS: sayThanks(PARAMETRO)

DEFAULT PARAMETERS: Sirven para cuando puede que no se ponga nada como parametro
function greeting (name = 'stranger') {
  console.log(`Hello, ${name}!`)
}

greeting('Nick') // Output: Hello, Nick!
greeting() // Output: Hello, stranger!

RETURN(procedure):
function multiplyByNineFifths(number) {
  return number * (9/5);
};

ANONYMOUS FUNCTION: Se le asigna una funcion a una variable
const plantNeedsWater = function(day) {
  if(day === 'Wednesday') {
    return true;
  } else {return false;}
}
console.log(plantNeedsWater('Tuesday')); // Prints: false

ARROW FUNCTION: Otra forma de escribir una anonymous function
const rectangleArea = (width, height) => {
  let area = width * height;
  return area;
};

-----LECCION 5-----
SCOPE
BLOCK: Lo que está dentro de las llaves {}
GLOBAL VARIABLES: They are not bound inside a block, they can be accessed by any code in the program
BLOCK SCOPE: When a variable is defined inside a block, 
it is only accessible to the code within the curly braces {} ( local variables )
SCOPE POLLUTION: when we have too many global variables that exist in the global namespace,
or when we reuse variables across different scopes. 
EJ:
let num = 50;

const logNum = () => {
  num = 100; // Take note of this line of code
  console.log(num);
};

logNum(); // Prints 100
console.log(num); // Prints 100

1-We have a variable num.
2-Inside the function body of logNum(), we want to declare a new variable but forgot to use the let keyword.
3-When we call logNum(), num gets reassigned to 100.
4-The reassignment inside logNum() affects the global variable num.

-----LECCION 6-----
ARRAYS (LISTAS)
EJ: let newYearsResolutions = ['Keep a journal', 'Take a falconry class', 'Learn to juggle'];
Arrays in JavaScript are zero-indexed, meaning the positions start counting from 0 rather than 1. 
Therefore, the first item in an array will be at position 0.

ARRAY BRACKETS:
let cities = ['New York', 'Beijing', 'Nairobi'];
console.log(cities[0]); //Output: New York

const hello = 'Hello World';
console.log(hello[6]); // Output: W

UPDATE:
let seasons = ['Winter', 'Spring', 'Summer', 'Fall'];
seasons[3] = 'Autumn';
console.log(seasons);  //Output: ['Winter', 'Spring', 'Summer', 'Autumn']

.LENGTH: It returns the number of items in the array. 
const newYearsResolutions = ['Keep a journal', 'Take a falconry class'];
console.log(newYearsResolutions.length); // Output: 2

.PUSH(): Allows us to add items to the end of an array. 
const itemTracker = ['item 0', 'item 1', 'item 2'];
itemTracker.push('item 3', 'item 4');
console.log(itemTracker);  // Output: ['item 0', 'item 1', 'item 2', 'item 3', 'item 4'];

.POP(): Removes the last item of an array.
const newItemTracker = ['item 0', 'item 1', 'item 2'];
const removed = newItemTracker.pop();
console.log(newItemTracker);  // Output: [ 'item 0', 'item 1' ]
console.log(removed);  // Output: item 2

MUTATION: Some built-in methods are mutating, meaning the method will change the array, 
while others are not mutating. You can always check the documentation.

ARRAYS AND FUNCTIONS:
const flowers = ['peony', 'daffodil', 'marigold'];
function addFlower(arr) {
  arr.push('lily');
}
addFlower(flowers);
console.log(flowers); // Output: ['peony', 'daffodil', 'marigold', 'lily']

NESTED ARRAY:
const nestedArr = [[1], [2, 3]];
console.log(nestedArr[1]); // Output: [2, 3]
onsole.log(nestedArr[1][0]); // Output: 2

-----LECCION 7-----
FOR:  It  includes an iterator variable that usually appears in all three expressions. 
The iterator variable is initialized, checked against the stopping condition, and assigned a 
new value on each loop iteration.

for (let counter = 0; counter < 4; counter++) {
  console.log(counter);
} 
// Output: 0
	   1
           2
           3

REVERSE: To run a backward for loop, we must:
Set the iterator variable to the highest desired value in the initialization expression.
Set the stopping condition for when the iterator variable is less than the desired amount.
The iterator should decrease in intervals after each iteration.
EJ:
for (let counter = 3; counter >= 0; counter--){
  console.log(counter);
}
// Output: 3
	   2
           1
           0

LOOPING THROUGH ARRAYS: Hace un loop sobre cada index del array
(i = index)
EJ:
const animals = ['Grizzly Bear', 'Sloth', 'Sea Lion'];
for (let i = 0; i < animals.length; i++){
  console.log(animals[i]);
}
// Output: Grizzly Bear
	   Sloth
	   Sea Lion

NESTED LOOPS: One use for a nested for loop is to compare the elements in two arrays. 
For each round of the outer for loop, the inner for loop will run completely.
EJ:
let bobsFollowers = ['Michael', 'Beatrice', 'Steve', 'Jessica'];
let tinasFollowers = ['Steve', 'Meave', 'Jessica'];
let mutualFollowers = [];
for (let i = 0; i < bobsFollowers.length; i++) {
  for (let j = 0; j < tinasFollowers.length; j++) {
    if (bobsFollowers[i] === tinasFollowers[j]) {
      mutualFollowers.push(bobsFollowers[i]);
    }
  }
}; 
console.log(mutualFollowers);

Esta linea de codigo carga a la consola el array mutualFollowers. Que lo que contiene son los seguidores en comun
entre Tina y Bob.

WHILE LOOPS: The syntax of a for loop is ideal when we know how many times the loop should run, 
but we don’t always know this in advance. Think of eating like a while loop: when you start taking bites, 
you don’t know the exact number you’ll need to become full. Rather you’ll eat while you’re hungry. 
In situations when we want a loop to execute an undetermined number of times, while loops are the best choice.
EJ:
// A for loop that prints 1, 2, and 3
for (let counterOne = 1; counterOne < 4; counterOne++){
  console.log(counterOne);
}

// A while loop that prints 1, 2, and 3
let counterTwo = 1;
while (counterTwo < 4) {
  console.log(counterTwo);
  counterTwo++;
}

DO...WHILE: When you want a piece of code to run at least once and then loop based on 
a specific condition after its initial run.
EJ:
let countString = '';
let i = 0;
do {
  countString = countString + i;
  i++;
} while (i < 5);
console.log(countString);

BREAK: We’re looking to adopt a dog. We plan to go to the shelter every day for a year and then give up. 
But what if we meet our dream dog on day 65? We don’t want to keep going to the shelter for the next 300 days.
In our code, when we want to stop a loop from continuing to execute even though the original stopping condition 
we wrote for our loop hasn’t been met, we can use the keyword BREAK.
EJ:
for (let i = 0; i < 99; i++) {
  if (i > 2 ) {
     break;
  }
  console.log('Banana.');
}
console.log('Orange you glad I broke out the loop!');
// Output: 	Banana.
		Banana.
		Banana.
		Orange you glad I broke out the loop!

-----LECCION 8-----
Optimizar espacio:
// La funcion original es announceThatIAmDoingImportantWork() 
const busy = announceThatIAmDoingImportantWork;

Notice how we assign announceThatIAmDoingImportantWork without parentheses as the value to the busy variable. 
We want to assign the value of the function itself, not the value it returns when invoked.

console.log(busy.name); //Output: announceThatIAmDoingImportantWork

HIGHER-ORDER FUNCTIONS: It's a function that either accepts functions as parameters, returns a function, or both.
We call the functions that get passed in as parameters and invoked "CALLBACK FUNCTIONS" because they get called 
during the execution of the higher-order function.
When we pass a function in as an argument to another function, we don’t invoke it. Invoking the function would 
evaluate to the return value of that function call. With callbacks, we pass in the function itself by typing 
the function name WITHOUT the parentheses (that would evaluate to the result of calling the function)

-----LECCION 9-----
ARRAY ITERATORS: They're methods called on arrays to manipulate elements and return values.

.forEach(): Aptly named, .forEach() will execute the same code for each element of an array.
EJ: 
const fruits = ['mango', 'papaya', 'pineapple', 'apple'];

fruits.forEach(fruitItem => console.log('I want to eat a ' + fruitItem));

//Prints:
I want to eat a mango
I want to eat a papaya
I want to eat a pineapple
I want to eat a apple

.map(): When .map() is called on an array, it takes an argument of a callback function and returns a new array.

EJ:
const numbers = [1, 2, 3, 4, 5]; 

const bigNumbers = numbers.map(number => {
  return number * 10;
});

In the example above: numbers.map will iterate through each element in the numbers array and pass the element
into the callback function.  return number * 10 is the code we wish to execute upon each element in the array. 
This will save each value from the numbers array, multiplied by 10, to a new array.

If we take a look at numbers and bigNumbers:

console.log(numbers); // Output: [1, 2, 3, 4, 5]
console.log(bigNumbers); // Output: [10, 20, 30, 40, 50]

.filter(): It returns an array of elements after filtering out certain elements from the original array. 
The callback function for the .filter() method should return true or false. The elements that cause the 
callback function to return true are added to the new array. 

EJ:
const words = ['chair', 'music', 'pillow', 'brick', 'pen', 'door']; 

const shortWords = words.filter(word => {
  return word.length < 6;
});

If we take a look at words and shortWords:

console.log(words); // Output: ['chair', 'music', 'pillow', 'brick', 'pen', 'door']; 
console.log(shortWords); // Output: ['chair', 'music', 'brick', 'pen', 'door']

.findIndex(): Calling it on an array will return the index of the first element that evaluates to true in the callback function.

EJ:
const jumbledNums = [123, 25, 78, 5, 9]; 

const lessThanTen = jumbledNums.findIndex(num => {
  return num < 10;
});

num < 10; is the condition that elements are checked against. .findIndex() will return the index of the first element
which evaluates to true for that condition.

If we take a look at lessThanTen:

console.log(lessThanTen); // Output: 3 

If there isn’t a single element in the array that satisfies the condition in the callback, then .findIndex() will return -1.

.reduce(): It returns a single value after iterating through the elements of an array, thereby reducing the array.

EJ:
const numbers = [1, 2, 4, 10];

const summedNums = numbers.reduce((accumulator, currentValue) => {
  return accumulator + currentValue
})

console.log(summedNums) // Output: 17

The .reduce() method can also take an optional second parameter to set an initial value for accumulator ( the first argument is the callback function).
EJ:
const numbers = [1, 2, 4, 10];

const summedNums = numbers.reduce((accumulator, currentValue) => {
  return accumulator + currentValue
}, 100)  // <- Second argument for .reduce()

console.log(summedNums); // Output: 117



-----LECCION 10-----
OBJECT: Objects can be assigned to variables just like any JavaScript type. We use curly braces, {}, to designate 
an object literal:

let spaceship = {}; // spaceship is an empty object

We fill an object with unordered data. This data is organized into key-value pairs. 
A key is like a variable name that points to a location in memory that holds a value.

// An object literal with two key-value pairs
let spaceship = {
  'Fuel Type': 'diesel', //KEY: VALUE
  color: 'silver'	 //KEY: VALUE
};

ACCESSING PROPERTIES:
	DOT NOTATION: We write the object’s name, followed by the dot operator and then the property name (key):
EJ:
let spaceship = {
  homePlanet: 'Earth',
  color: 'silver'
};
spaceship.homePlanet; // Returns 'Earth',
spaceship.color; // Returns 'silver',

If we try to access a property that does not exist on that object, undefined will be returned.

spaceship.favoriteIcecream; // Returns undefined

Puedo asignarle a nuevas variables el valor de una key del objeto.
EJ:
let spaceship = {
  numCrew: 5,
  flightPath: ['Venus', 'Mars', 'Saturn']
};

let crewCount = spaceship.numCrew;
let planetArray = spaceship.flightPath;

BRACKET NOTATION: The second way to access a key’s value is by using bracket notation, [ ].
To use bracket notation to access an object’s property, we pass in the property name (key) as a string.
We MUST use bracket notation when accessing keys that have numbers, spaces, or special characters in them.
Without bracket notation in these situations, our code would throw an error.
EJ:
let spaceship = {
  'Fuel Type': 'Turbo Fuel',
  'Active Duty': true,
  homePlanet: 'Earth',
  numCrew: 5
};
spaceship['Active Duty'];   // Returns true
spaceship['Fuel Type'];   // Returns  'Turbo Fuel'
spaceship['numCrew'];   // Returns 5
spaceship['!!!!!!!!!!!!!!!'];   // Returns undefined

With bracket notation you can also use a variable inside the brackets to select the keys of an object. 
This can be especially helpful when working with functions:

let returnAnyProp = (objectName, propName) => objectName[propName];

returnAnyProp(spaceship, 'homePlanet'); // Returns 'Earth'

MUTATION: Objects are mutable. We can use either dot notation, ., or bracket notation, [], and the 
assignment operator, = to add new key-value pairs to an object or change an existing property.
Although we can’t reassign an object declared with const, we can still mutate it, meaning we can 
add new properties and change the properties that are there.

const spaceship = {type: 'shuttle'};
spaceship = {type: 'alien'}; // TypeError: Assignment to constant variable.
spaceship.type = 'alien'; // Changes the value of the type property
spaceship.speed = 'Mach 5'; // Creates a new key of 'speed' with a value of 'Mach 5'

DELETE: You can delete a property from an object with the delete operator.

const spaceship = {
  'Fuel Type': 'Turbo Fuel',
  homePlanet: 'Earth',
  mission: 'Explore the universe' 
};

delete spaceship.mission;  // Removes the mission property

OBJECT METHOD: When the data stored on an object is a function we call that a method. 
A property is what an object has, while a method is what an object does.
EJ:
let alienShip = {
  retreat () {
    console.log(retreatMessage);
  },
  takeOff() {
    console.log('Spim... Borp... Glix... Blastoff!');
  }
}

alienShip.takeOff(); // Prints 'Spim... Borp... Glix... Blastoff!'

NESTED OBJECTS:
const spaceship = {
     telescope: {
        yearBuilt: 2018,
        model: '91031-XLT',
        focalLength: 2032 
     },
    crew: {
        captain: { 
            name: 'Sandra', 
            degree: 'Computer Engineering', 
            encourageTeam() { console.log('We got this!') } 
         }
    }
}; 

REASIGNAR PARAMETROS:
let spaceship = {
  'Fuel Type' : 'Turbo Fuel',
  homePlanet : 'Earth'
};


 function greenEnergy(obj) {
   obj['Fuel Type'] = 'avocado oil';
 }

function remotelyDisable(obj) {
  obj.disabled = true;
}

greenEnergy(spaceship)
remotelyDisable(spaceship)

console.log(spaceship) // PRINTS: { 'Fuel Type': 'avocado oil',
				    homePlanet: 'Earth',
				    disabled: true }

LOOPING THROUGH OBJECTS: We use the "for...in"
EJ: 
for (let crewMember in spaceship.crew) {
  console.log(`${crewMember}: ${spaceship.crew[crewMember].name}`)
};

-----LECCION 11-----
METHODS IN OBJECTS: Objects are collections of related data and functionality. 
We store that functionality in methods on our objects:

const goat = {
  dietType: 'herbivore',
  makeSound() {
    console.log('baaa');
  }
};

In our goat object we have a .makeSound() method. We can invoke the .makeSound() method on goat.

goat.makeSound(); // Prints baaa

THE THIS METHOD:

What if we wanted to add a new method to our goat object called .diet() that prints the goat‘s dietType?

const goat = {
  dietType: 'herbivore',
  makeSound() {
    console.log('baaa');
  },
  diet() {
    console.log(dietType);
  }
};

goat.diet();
// Output will be "ReferenceError: dietType is not defined"

Why is dietType not defined even though it’s a property of goat? That’s because inside the scope of the .diet() 
method, we don’t automatically have access to other properties of the goat object. Here’s where the this keyword 
comes to the rescue. If we change the .diet() method to use the this, the .diet() works! :

const goat = {
  dietType: 'herbivore',
  makeSound() {
    console.log('baaa');
  },
  diet() {
    console.log(this.dietType);
  }
};

goat.diet();
// Output: herbivore

The this keyword references the calling object which provides access to the calling object’s properties. 
In the example above, the calling object is goat and by using this we’re accessing the goat object itself, 
and then the dietType property of goat by using property dot notation.

NO usar arrow functions y el this a la vez, ya que no funciona.

PRIVACY: A common convention is to place an underscore _ before the name of a property to mean that the 
property should not be altered.
EJ:

const bankAccount = {
  _amount: 1000
}
 Aun así, se puede cambiar su valor, es mas que nada una guía para saber que dicha propiedad no debería ser cambiada.

GETTERS: They are methods that get and return the internal properties of an object.

Notable advantages of using getter methods:
* Getters can perform an action on the data when getting a property.
* Getters can return different values using conditionals.
* In a getter, we can access the properties of the calling object using this.

Ej:

const robot = {
  _model: '1E78V2',
  _energyLevel: 100,
  get energyLevel() {
    if(typeof this._energyLevel === 'number') {
      return `My current energy level is ${this._energyLevel}`
    } else {
      return `System malfunction: cannot retrieve energy level`
    }
  }
};

SETTERS: We can also create setter methods which reassign values of existing properties within an object.
EJ:

const person = {
  _age: 37,
  set age(newAge){
    if (typeof newAge === 'number'){
      this._age = newAge;
    } else {
      console.log('You must assign a number to age');
    }
  }
};

In the example above:
* We can perform a check for what value is being assigned to this._age.
* When we use the setter method, only values that are numbers will reassign this._age
* There are different outputs depending on what values are used to reassign this._age.

Then to use the setter method:
person.age = 40;
console.log(person._age); // Logs: 40
person.age = '40'; // Logs: You must assign a number to age

Notable advantages of using setter methods:  Checking input, performing actions on properties, 
and displaying a clear intention for how the object is supposed to be used.

Reassigning properties: Nonetheless, even with a setter method, it is still possible to directly reassign properties. 
For example, in the example above, we can still set ._age directly:
person._age = 'forty-five'
console.log(person._age); // Prints forty-five

FACTORY FUNCTIONS: Factory function is a function that returns an object and can be reused to make multiple object instances. 
Factory functions can also have parameters. Es como un objeto dentro de una funcion. Let’s say we wanted to create 
an object to represent monsters. There are many different types of monsters and we could go about making 
each monster individually but we can also use a factory function to make our lives easier.
Ej:
const monsterFactory = (name, age, energySource, catchPhrase) => {
  return {
    name: name,
    age: age,
    energySource: energySource,
    scare() {
      console.log(catchPhrase);
    }
  }
};

To make an object that represents a specific monster like a ghost, we can call monsterFactory with the necessary 
arguments and assign the return value to a variable:

const ghost = monsterFactory('Ghouly', 251, 'ectoplasm', 'BOO!');
ghost.scare(); // 'BOO!'

Now we have a ghost object as a result of calling monsterFactory() with the needed arguments.

PROPERTY VALUE SHORTHAND: Es una manera de escribir una factory function mas rápido, te ahorras caracteres 
al establecer y asignar las propiedades.
Ej:
const monsterFactory = (name, age) => {
  return {
    name,
    age
  }
};

DESTRUCTURED ASSIGNMENT: Escribe de una manera mas comoda y económica la sintaxis de extraer una key de
un objeto y guardarla como una variable.

Ej:
const vampire = {
  name: 'Dracula',
  residence: 'Transylvania',
  preferences: {
    day: 'stay inside',
    night: 'satisfy appetite'
  }
};

Ej de una asignación hecha de forma normal:
const residence = vampire.residence;
console.log(residence); // Prints 'Transylvania'

Ej de una asignación hecha de forma ‘destructured’:
const { residence } = vampire;
console.log(residence); // Prints 'Transylvania'

Ej de una asignación de una nested property hecha de forma ‘destructured’:
const { day } = vampire.preferences;
console.log(day); // Prints 'stay inside'

BUILT-IN OBJECTS METHODS: Algunos ejemplos de métodos para objetos ya hechos

const robot = {
model: 'SAL-1000',
  mobile: true,
  sentient: false,
  armor: 'Steel-plated',
  energyLevel: 75
};

Object.keys(): It returns an array of a given object's own enumerable property names, iterated in the same 
order that a normal loop would.

const robotKeys = Object.keys(robot);
console.log(robotKeys); // Prints: [ 'model', 'mobile', 'sentient', 'armor', 'energyLevel' ]

Object.entries(): It returns an array, but the array will contain more arrays that have both the key and 
value of the properties in an object.

const robotEntries = Object.entries(robot)
console.log(robotEntries);
//Prints:
[ [ 'model', 'SAL-1000' ],
  [ 'mobile', true ],
  [ 'sentient', false ],
  [ 'armor', 'Steel-plated' ],
  [ 'energyLevel', 75 ] ]

Object.assign(): copies all enumerable own properties from one or more source objects to a target object. 
It returns the target object.

const newRobot = Object.assign({laserBlaster: true, voiceRecognition: true}, robot);
console.log(newRobot);
//Prints: { laserBlaster: true,
  voiceRecognition: true,
  model: 'SAL-1000',
  mobile: true,
  sentient: false,
  armor: 'Steel-plated',
  energyLevel: 75 }

-----LECCION 12-----
CLASSES: Imagine you own a dog daycare and want to create a catalog of all the dogs who belong to the daycare. 
Instead of creating a whole new object for every dog that joins the daycare, we can create a Dog class that
serves as a template for creating new Dog objects. For each new dog, you can provide a value for their name.
Classes are a great way to reduce duplicate code and debugging time.
EJ:
class Dog {
  constructor(name) {
    this._name = name;
    this._behavior = 0;
  }

  get name() {
    return this._name;
  }
  get behavior() {
    return this._behavior;
  }   

  incrementBehavior() {
    this._behavior ++;
  }
}

const halley = new Dog('Halley');
console.log(halley.name); // Print name value to console: Halley
console.log(halley.behavior); // Print behavior value to console: 0
halley.incrementBehavior(); // Add one to behavior
console.log(halley.name); // Print name value to console: : Halley
console.log(halley.behavior); // Print behavior value to console: 1

The whole code above created a class called Dog, and used it to produce a Dog object.

CONSTRUCTOR: JavaScript calls the constructor() method every time it creates a new instance of a class.

class Dog {
  constructor(name) {
    this.name = name;
    this.behavior = 0;
  }
} 
* Dog is the name of our class. By convention, we capitalize class names.
* JavaScript will invoke the constructor() method every time we create a new instance of our Dog class.
* This constructor() method accepts one argument, name.
* Inside of the constructor() method, we use the this keyword. In the context of a class, this refers 
to an instance of that class. In the Dog class, we use this to set the value of the Dog instance’s name 
property to the name argument.
* Under this.name, we create a property called behavior, which will keep track of the number of times a dog
misbehaves. The behavior property is always initialized to zero.

INSTANCE: An instance is an object that contains the property names and methods of a class, but with 
unique property values.

class Dog {
  constructor(name) {
    this.name = name;
    this.behavior = 0;
  } 
}

const halley = new Dog('Halley'); // Create new Dog INSTANCE
console.log(halley.name); // Log the name value saved to halley
// Output: 'Halley'

Below our Dog class, we use the new keyword to create an instance of our Dog class.

* We create a new variable named halley that will store an INSTANCE of our Dog class.
* We use the NEW keyword to generate a new INSTANCE of the Dog class. The NEW keyword calls the constructor(), 
runs the code inside of it, and then returns the new instance.
* We pass the 'Halley' string to the Dog constructor, which sets the name property to 'Halley'.
* Finally, we log the value saved to the name key in our halley object, which logs 'Halley' to the console.

METHODS: Class method and getter syntax is the same as it is for objects except you can not include commas between methods.

class Dog {
  constructor(name) {
    this._name = name;
    this._behavior = 0;
  }

  get name() {
    return this._name;
  }

  get behavior() {
    return this._behavior;
  }

  incrementBehavior() {
    this._behavior++;
  }
}

Notice, we also prepended our property names with underscores (_name and _behavior), which indicate these properties
should not be accessed directly.

INHERITANCE: When multiple classes share properties or methods, they become candidates for inheritance.
With inheritance, you can create a parent class (also known as a superclass) with properties and methods 
that multiple child classes (also known as subclasses) share. The child classes inherit the properties and
methods from their parent class.

EJ: CREO LA MAMÁ CLASE "Animal" QUE VA A TENER COMO CLASES HIJAS A "Dog" Y "Cat".

class Animal {
  constructor(name) {
    this._name = name;
    this._behavior = 0;
  }

  get name() {
    return this._name;
  }

  get behavior() {
    return this._behavior;
  }   

  incrementBehavior() {
    this._behavior++;
  }
} 

Now that we have these shared properties and methods in the parent Animal class, we can extend them to the subclass, Cat.

class Cat extends Animal {
  constructor(name, usesLitter) {
    super(name);
    this._usesLitter = usesLitter;
  }
}

Let’s pay special attention to our new keywords: EXTENDS and SUPER.

* The EXTENDS keyword makes the methods of the animal class available inside the cat class.
* The constructor, called when you create a new Cat object, accepts two arguments, name and usesLitter.
* The SUPER keyword calls the constructor of the parent class. In this case, super(name) passes the name
  argument of the Cat class to the constructor of the Animal class. When the Animal constructor runs, it sets
  this._name = name; for new Cat instances.
* _usesLitter is a new property that is unique to the Cat class, so we set it in the Cat constructor.

Notice, we call SUPER on the first line of our constructor(), then set the usesLitter property on the second line. 
In a constructor(), you must always call the SUPER method before you can use the THIS keyword.
 
CHILD METHODS: Child classes can contain their own properties, getters, setters, and methods.
EJ:

class Cat extends Animal {
  constructor(name, usesLitter) {
    super(name);
    this._usesLitter = usesLitter;
  }

  get usesLitter() {
    return this._usesLitter;
  }
}

One benefit OF inheritance is that when you need to change a method or property that multiple classes share,
you can change the parent class, instead of each subclass.

STATIC METHODS: Sometimes you will want a class to have methods that aren’t available in individual instances, 
or sub classes, but that you can call directly from the class.

EJ:

class Animal {
  constructor(name) {
    this._name = name;
    this._behavior = 0;
  }

  static generateName() {
    const names = ['Angel', 'Spike', 'Buffy', 'Willow', 'Tara'];
    const randomNumber = Math.floor(Math.random()*5);
    return names[randomNumber];
  }
} 

In the example above, we create a STATIC method called .generateName() that returns a random name when it’s called. 
Because of the STATIC keyword, we can only access .generateName() by appending it to the Animal class.

We call the .generateName() method with the following syntax (See below):
console.log(Animal.generateName()); // returns a name

You cannot access the .generateName() method from instances of the Animal class or instances of its subclasses (See below).
const tyson = new Animal('Tyson'); 
tyson.generateName(); // TypeError

The example above will result in an error, because you cannot call STATIC methods (.generateName()) on an instance (tyson).

-----LECCION 13-----
BROWSER COMPATIBILITY AND TRANSPILATION:
caniuse.com: While most new browser versions support the majority of the ES6 library, there are still a couple sources of 
compatibility issues:
Some users have not updated to the latest, ES6 supported web browser version.
A few ES6 features, like modules, are still not supported by most web browsers.
Because companies add support for ES6 features gradually, it’s important for you to know how to look up browser support 
on a feature-by-feature basis. The website caniuse.com is the best resource for finding browser compatibility information.
In caniuse, you can enter an ES6 feature, like let, and see the percentage of browsers that recognize it. 
You can also see when each major web browser added support for the keyword.

WHY ES6?: Three reasons for the ES5 to ES6 updates are listed below:
* Readability and economy of code — The new syntax is often easier to understand (more readable) and requires 
fewer characters to create the same functionality (economy of code).
* Addresses sources of ES5 bugs — Some ES5 syntax led to common bugs. With ES6, Ecma introduced syntax that mitigates
some of the most common pitfalls.
* A similarity to other programming languages — JavaScript ES6 is syntactically more similar to other object-oriented
programming languages. This leads to less friction when experienced, non-JavaScript developers want to learn JavaScript.

TRANSPILATION WITH BABEL: Because ES6 is predictably backwards compatible, a collection of JavaScript programmers developed
a JavaScript library called Babel that transpiles ES6 JavaScript to ES5.
Transpilation is the process of converting one programming language to another. 

Para transformar entonces de ES6 a ES5 escribo en la consola lo siguiente:
npm install babel-cli
Luego escribo esto
:npm install babel-preset-env
Y finalemnte termino con esto:
npm run build
You can view the ES5 code in ./lib/main.js.

For future reference, here is a list of the steps needed to set up a project for transpilation:

1 -Initialize your project using npm init and create a directory called src
2 -Install babel dependencies by running
	npm install babel-cli -D
	npm install babel-preset-env -D
3 -Create a .babelrc file inside your project (Run touch .babelrc to add the .babelrc file to the root directory.)
and add the following code inside it:
        {
          "presets": ["env"]
	}
4 -Add the following script to your scripts object below the "test" script in package.json:
	"build": "babel src -d lib"
5 -Run npm run build whenever you want to transpile your code from your src to lib directories.

-----LECCION 14-----
MODULES: Modules are particularly useful for a number of reasons. By separating code with similar logic into
files called modules, we can:
* find, fix, and debug code more easily;
* reuse and recycle defined logic in different parts of our application;
* keep information private and protected from other modules;
* and, importantly, prevent pollution of the global namespace and potential naming collisions, by cautiously 
selecting variables and behavior we load into a program.

MODULE.EXPORTS: We can get started with modules by defining a module in one file and making the module available for use in 
another file with Node.js module.exports syntax.
EJ:

let Menu = {};
Menu.specialty = "Roasted Beet Burger with Mint Sauce";

module.exports = Menu; 

The pattern we use to export modules is thus:
1 -Create an object to represent the module.
2 -Add properties or methods to the module object.
3 -Export the module with module.exports.

REQUIRE(): To make use of the exported module and the behavior we define within it, we import the module into
another file. In Node.js, use the require() function to import modules.
For instance, say we want the module to control the menu’s data and behavior, and we want a separate file to 
handle placing an order. We would create a separate file order.js and import the Menu module from menu.js to order.js 
using require(). require() takes a file path argument pointing to the original module file.

In order.js we would write:

const Menu = require('./menu.js');

function placeOrder() {
  console.log('My order is: ' + Menu.specialty);
}

placeOrder();

We now have the entire behavior of Menu available in order.js. Here, we notice:

1 -In order.js we import the module by creating a const variable called Menu and setting it equal to the value of 
the require() function. We can set the name of this variable to anything we like, such as menuItems.
2 -require() is a JavaScript function that loads a module. It’s argument is the file path of the module: ./menu.js.
With require(), the .js extension is optional and will be assumed if it is not included.
3 -The placeOrder() function then uses the Menu module. By calling Menu.specialty, we access the property specialty 
defined in the Menu module.

MODULE.EXPORTS 2: We can also wrap any collection of data and functions in an object, and export the object using 
module.exports. 
In menu.js, we could write:

module.exports = {
  specialty: "Roasted Beet Burger with Mint Sauce",
  getSpecialty: function() {
    return this.specialty;
  } 
};

In the above code, notice:
1 -module.exports exposes the current module as an object.
2 -specialty and getSpecialty are properties on the object. 

Then in order.js, we write:

const Menu = require('./menu.js');

console.log(Menu.getSpecialty());

EXPORT DEFAULT: A new more readable and flexible syntax for exporting modules (ES6).
EJ:

let Menu = {};

export default Menu;

1 -export default uses the JavaScript export statement to export JavaScript objects, functions, and primitive data
types.
2 -Menu refers to the name of the Menu object, the object that we are setting the properties on within our modules.

When using ES6 syntax, we use EXPORT DEFAULT in place of MODULE.EXPORTS. Node.js doesn’t support EXPORT DEFAULT by 
default, so MODULE.EXPORTS is usually used for Node.js development and ES6 syntax is used for front-end development.
ENTONCES, EXPORT DEFAULT ES PARA FRONT END Y MODULE.EXPORTS PARA BACK END.

IMPORT: In our order.js example, we import an object like this:

import Menu from './menu';

1- The import keyword begins the statement.
2- The keyword Menu here specifies the name of the variable to store the default export in.
3- from specifies where to load the module from.
4- './menu' is the name of the module to load. When dealing with local files, it specifically refers to the name
of the file without the extension of the file(.js).
We can then continue using the Menu module in the order.js file.

NAMED EXPORTS: ES6 introduced a second common approach to export modules. In addition to export default, 
named exports allow us to export data through the use of variables. 

In menu.js we would be sure to give each piece of data a distinct variable name:

let specialty = '';
function isVegetarian() {
}; 
function isLowSodium() {
}; 

export { specialty, isVegetarian };

1- Notice that, when we use named exports, we are not setting the properties on an object. Each export is stored 
in its own variable.
2- specialty is a string object, while isVegetarian and isLowSodium are objects in the form of functions. Recall 
that in JavaScript, every function is in fact a function object.
3- export { specialty, isVegetarian }; exports objects by their variable names. Notice the keyword export is the prefix.
4- specialty and isVegetarian are exported, while isLowSodium is not exported, since it is not specified in the 
export syntax.

NAMED IMPORTS: To import objects stored in a variable, we use the import keyword and include the variables in a set of {}.
EJ:

import { specialty, isVegetarian } from './menu';

console.log(specialty);

1- Here specialty and isVegetarian are imported.
2- If we did not want to import either of these variables, we could omit them from the import statement.
3- We can then use these objects as in within our code. For example, we would use specialty instead of Menu.specialty.

EXPORT NAMED EXPORTS: Named exports are also distinct in that they can be exported as soon as they are declared, by 
placing the keyword export in front of variable declarations.
EJ:

export let specialty = '';
export function isVegetarian() {
}; 
function isLowSodium() {
}; 

1- The export keyword allows us to export objects upon declaration, as shown in export let specialty and export 
function isVegetarian() {}.
2- We no longer need an export statement at the bottom of our file, since this behavior is handled above.

IMPORT NAMED IMPORTS: To import variables that are declared, we simply use the original syntax that describes the 
variable name. In other words, exporting upon declaration does not have an impact on how we import the variables.
EJ:

import { specialty, isVegetarian } from 'menu';

EXPORT AS: Named exports also offer a way to change the name of variables when we export or import them. 
We can do this with the AS keyword.
EJ:

let specialty = '';
let isVegetarian = function() {
}; 
let isLowSodium = function() {
}; 

export { specialty as chefsSpecial, isVegetarian as isVeg, isLowSodium };

1- The as keyword allows us to give a variable name an alias as demonstrated in 
specialty as chefsSpecial and isVegetarian as isVeg.
2- Since we did not give isLowSodium an alias, it will maintain its original name.

IMPORT AS: To import named export aliases with the as keyword, we add the aliased variable in our import statement.
EJ:

import { chefsSpecial, isVeg } from './menu';

1- We import chefsSpecial and isVeg from the Menu object.
2- Here, note that we have an option to alias an object that was not previously aliased when exported. 
For example, the isLowSodium object that we exported could be aliased with the as keyword when imported: 
import {isLowSodium as saltFree} from 'Menu';

Another way of using aliases is to import the entire module as an alias:

import * as Carte from './menu';

Carte.chefsSpecial;
Carte.isVeg();
Carte.isLowSodium(); 

1- This allows us to import an entire module from menu.js as an alias Carte.
2- In this example, whatever name we exported would be available to us as properties of that module. 
For example, if we exported the aliases chefsSpecial and isVeg, these would be available to us. 
If we did not give an alias to isLowSodium, we would call it as defined on the Carte module.

COMBINING EXPORT STATEMENTS: We can also use named exports and default exports together. 
EJ:

export { specialty as chefsSpecial, isVegetarian as isVeg };
export default isGlutenFree;

While it’s better to avoid combining two methods of exporting, it is useful on occasion. 
For example, if you suspect developers may only be interested in importing a specific function and 
won’t need to import the entire default export.

COMBINING IMPORT STATEMENTS: We can import the collection of objects and functions with the same data.
EJ:

import { specialty, isVegetarian, isLowSodium } from './menu';
import GlutenFree from './menu';

-----LECCION 15-----
ASYNCHRONOUS PROGRAMMING: An asynchronous operation is one that allows the computer to “move on” to
other tasks while waiting for the asynchronous operation to complete

There are countless examples of asynchronicity in our everyday lives. Cleaning our house, for example, 
involves asynchronous operations such as a dishwasher washing our dishes or a washing machine washing 
our clothes. While we wait on the completion of those operations, we’re free to do other chores.

PROMISE:They are objects that represent the eventual outcome of an asynchronous operation. 

A Promise object can be in one of three states:
* Pending: The initial state— the operation has not completed yet.
* Fulfilled: The operation has completed successfully and the promise now has a resolved value. For 
example, a request’s promise might resolve with a JSON object as its value.
* Rejected: The operation has failed and the promise has a reason for the failure. This reason is 
usually an Error of some kind.

SETTLED PROMISE: We refer to a promise as settled if it is no longer pending. It is either FULFILLED or REJECTED.

CONSTRUCTING A PROMISE OBJECT: To create a new Promise object, we use the new keyword and 
the Promise constructor method:

const executorFunction = (resolve, reject) => { };
const myFirstPromise = new Promise(executorFunction);

The executor function has two function parameters, usually referred to as the resolve() and reject() functions. 
The resolve() and reject() functions aren’t defined by the programmer. When the Promise constructor runs, 
JavaScript will pass its own resolve() and reject() functions into the executor function.

* RESOLVE is a function with one argument. If invoked, resolve() will change the promise’s status 
from pending to fulfilled, and the promise’s resolved value will be set to the argument passed into resolve().
* REJECT is a function that takes a reason or error as an argument. If invoked, reject() will change the
promise’s status from pending to rejected, and the promise’s rejection reason will be set to the argument
passed into reject().

PROMISE CONSTRUCTOR EJ:

const executorFunction = (resolve, reject) => {
  if (someCondition) {
      resolve('I resolved!');
  } else {
      reject('I rejected!'); 
  }
}
const myFirstPromise = new Promise(executorFunction);

* myFirstPromise is constructed using new Promise() which is the Promise constructor method.
* executorFunction() is passed to the constructor and has two functions as parameters: resolve and reject.

PARA VER EL RESULTADO CONSOLE-LOGUEO myFirstPromise Y LUEGO EN LA CONSOLA ESCRIBO node app.js
(app.js es el nombre del archivo).

setTimeout() FUNCTION: It uses callback functions to schedule tasks to be performed after a delay. setTimeout() 
has two parameters: a callback function and a delay in milliseconds.
EJ:

const delayedHello = () => {
  console.log('Hi! This is an asynchronous greeting!');
};

setTimeout(delayedHello, 2000);

Here, we invoke setTimeout() with the callback function delayedHello() and 2000. In at least 
two seconds delayedHello() will be invoked.
Why is it “at least” two seconds and not exactly two seconds?
This delay is performed asynchronously—the rest of our program won’t stop executing during the delay. 
After two seconds, delayedHello() is added to a line of code waiting to be run. Before it can run, any 
synchronous code from the program will run. Next, any code in front of it in the line will run. This means 
it might be more than two seconds before delayedHello() is actually executed.

.THEN():Promise objects come with an aptly named .then() method. It allows us to say, “I have a promise, 
when it settles, then here’s what I want to happen…”

In the case of our dishwasher promise, the dishwasher will run. Then...:
* If our promise rejects, this means we have dirty dishes, and we’ll add soap and run the dishwasher again.
* If our promise fulfills, this means we have clean dishes, and we’ll put the dishes away.

.then() is a higher-order function— it takes two callback functions as arguments. We refer to these callbacks 
as HANDLERS. When the promise settles, the appropriate handler will be invoked with that settled value.

* The first handler, sometimes called onFulfilled, is a success handler, and it should contain the logic for
the promise resolving.
* The second handler, sometimes called onRejected, is a failure handler, and it should contain the logic for
the promise rejecting.

One important feature of .then() is that it always returns a promise.

EJ:

let prom = new Promise((resolve, reject) => {
  let num = Math.random();
  if (num < .5 ){
    resolve('Yay!');
  } else {
    reject('Ohhh noooo!');
  }
});

const handleSuccess = (resolvedValue) => {
  console.log(resolvedValue);
};

const handleFailure = (rejectionReason) => {
  console.log(rejectionReason);
};

prom.then(handleSuccess, handleFailure);

Let’s break down what’s happening in the example code:

* prom is a promise which will randomly either resolve with 'Yay!'or reject with 'Ohhh noooo!'.
* We pass two handler functions to .then(). The first will be invoked with 'Yay!' if the promise resolves, 
and the second will be invoked with 'Ohhh noooo!' if the promise rejects.

SEPARATION OF CONCERNS: It means organizing code into distinct sections each handling a specific task. 
It enables us to quickly navigate our code and know where to look if something isn’t working.

This implementation allows us to separate our resolved logic from our rejected logic. Instead of passing 
both handlers into one .then(), we can chain a second .then() with a failure handler to a first .then() 
with a success handler and both cases will be handled.
EJ:

prom
  .then((resolvedValue) => {
    console.log(resolvedValue);
  })
  .then(null, (rejectionReason) => {
    console.log(rejectionReason);
  });

.catch() FUNCTION: Using .catch() accomplishes the same thing as using a .then() with only a failure handler.
No tenemos que usar el "null" como en el .then.then.
EJ:

prom
  .then((resolvedValue) => {
    console.log(resolvedValue);
  })
  .catch((rejectionReason) => {
    console.log(rejectionReason);
  });

* prom is a promise which randomly either resolves with 'Yay!' or rejects with 'Ohhh noooo!'.
* We pass a success handler to .then() and a failure handler to .catch().
* If the promise resolves, .then()‘s success handler will be invoked with 'Yay!'.
* If the promise rejects, .then() will return a promise with the same rejection reason as the original promise 
and .catch()‘s failure handler will be invoked with that rejection reason.

PROMISE CHAINS: Multiple operations which depend on each other to execute or that must be executed in 
a certain order.
EJ:

firstPromiseFunction()
.then((firstResolveVal) => {
  return secondPromiseFunction(firstResolveVal);
})
.then((secondResolveVal) => {
  console.log(secondResolveVal);
});

PROMISE.ALL(): What if we’re dealing with multiple promises, but we don’t care about the order? Let’s think 
in terms of cleaning again:
For us to consider our house clean, we need our clothes to dry, our trash bins emptied, and the dishwasher
to run. We need all of these tasks to complete but not in any particular order. Furthermore, since they’re 
all getting done asynchronously, they should really all be happening at the same time!
To maximize efficiency we should use CONCURRENCY, multiple asynchronous operations happening together. 
With promises, we can do this with the function Promise.all().

Promise.all() accepts an array of promises as its argument and returns a single promise. That single promise
will settle in one of two ways:
* If every promise in the argument array resolves, the single promise returned from Promise.all() will resolve
with an array containing the resolve value from each promise in the argument array.
* If any promise from the argument array rejects, the single promise returned from Promise.all() will 
immediately reject with the reason that promise rejected.

EJ:

let myPromises = Promise.all([returnsPromOne(), returnsPromTwo(), returnsPromThree()]);

myPromises
  .then((arrayOfValues) => {
    console.log(arrayOfValues);
  })
  .catch((rejectionReason) => {
    console.log(rejectionReason);
  });

-----LECCION 16-----
ASYNC: It is used to write functions that handle asynchronous actions. We wrap our asynchronous logic inside
a function prepended with the async keyword. Then, we invoke that function.

async functions always return a promise. This means we can use traditional promise syntax, like .then() and 
.catch with our async functions. 
An async function will return in one of three ways:

* If there’s nothing returned from the function, it will return a promise with a resolved value of undefined.
* If there’s a non-promise value returned from the function, it will return a promise resolved to that value.
* If a promise is returned from the function, it will simply return that promise
EJ:

async function fivePromise() { 
  return 5;
}

fivePromise()
.then(resolvedValue => {
    console.log(resolvedValue);
  })  // Prints 5

In the example above, even though we return 5 inside the function body, what’s actually returned when we invoke
fivePromise() is a promise with a resolved value of 5.

AWAIT:The await keyword can only be used inside an async function. await is an operator: it returns the resolved 
value of a promise. Since promises resolve in an indeterminate amount of time, await pauses the execution of our 
async function until a given promise is resolved.

EJ:
In the example below, myPromise() is a function that returns a promise which will resolve to the string 
"I am resolved now!".

async function asyncFuncExample(){
  let resolvedValue = await myPromise();
  console.log(resolvedValue);
}

asyncFuncExample(); // Prints: I am resolved now!

Within our async function, asyncFuncExample(), we use await to halt our execution until myPromise() is resolved
and assign its resolved value to the variable resolvedValue

HANDLING DEPENDENT PROMISES: The true beauty of async...await is when we have a series of asynchronous actions 
which depend on one another. 
EJ (AS A NORMAL FUNCTION):

function nativePromiseVersion() {
    returnsFirstPromise()
    .then((firstValue) => {
        console.log(firstValue);
        return returnsSecondPromise(firstValue);
    })
   .then((secondValue) => {
        console.log(secondValue);
    });
}

EJ (AS AN ASYNC... AWAIT FUNCTION):

async function asyncAwaitVersion() {
 let firstValue = await returnsFirstPromise();
 console.log(firstValue);
 let secondValue = await returnsSecondPromise(firstValue);
 console.log(secondValue);
}  

CATCH EN ASYNC:

async function hostDinnerParty() {
  try {
    let resolvedValue = await cookBeanSouffle();
    console.log(`${resolvedValue} is served!`);
  } catch (error) {
    console.log(error);
    console.log('Ordering a pizza!');
  }
};

WAITING VS CONCURRENT:

async function waiting() {
 const firstValue = await firstAsyncThing();
 const secondValue = await secondAsyncThing();
 console.log(firstValue, secondValue);
}

async function concurrent() {
 const firstPromise = firstAsyncThing();
 const secondPromise = secondAsyncThing();
console.log(await firstPromise, await secondPromise);
}

In the waiting() function, we pause our function until the first promise resolves, then we construct the second
promise. Once that resolves, we print both resolved values to the console.
In our concurrent() function, both promises are constructed without using await. We then await each of their
resolutions to print them to the console.

With our concurrent() function both promises’ asynchronous operations can be run simultaneously. If possible, 
we want to get started on each asynchronous operation as soon as possible! Within our async functions we should
still take advantage of concurrency, the ability to perform asynchronous actions at the same time.

Una interpolation con await se escribe asi: 
console.log(`Dinner is served. We're having ${await starchPromise}, ${await proteinPromise}, and ${await sidePromise}.`)

AWAIT PROMISE.ALL(): We can pass an array of promises as the argument to Promise.all(), and it will return 
a single promise. This promise will resolve when all of the promises in the argument array have resolved. 
This promise’s resolve value will be an array containing the resolved values of each promise from 
the argument array.

async function asyncPromAll() {
  const resultArray = await Promise.all([asyncTask1(), asyncTask2(), asyncTask3(), asyncTask4()]);
  for (let i = 0; i < resultArray.length; i++){
    console.log(resultArray[i]); 
  }
};

In our above example, we await the resolution of a Promise.all(). This Promise.all() was invoked with an argument 
array containing four promises (returned from required-in functions). Next, we loop through our resultArray, 
and log each item to the console. The first element in resultArray is the resolved value of the asyncTask1() 
promise, the second is the value of the asyncTask2() promise, and so on.

-----LECCION 17-----
HTTP REQUESTS: One of JavaScript’s greatest assets is its an asynchronous language. AJAX, which stands for 
Asynchronous JavaScript and XML, is a set of tools that are used together to take advantage of JavaScript’s 
asynchronous capabilities.

Websites, like newspaper websites, take advantage of these non-blocking properties to provide a better user 
experience. Generally, a site’s code is written so that users don’t have to wait for a giant image to load 
before being allowed to read the actual article—rather, that text is rendered first and then the image can 
load in the background.

JavaScript uses an "event loop" to handle asynchronous function calls. When a program is run, function calls are 
made and added to a stack. The functions that make requests that need to wait for servers to respond then get 
sent to a separate queue. Once the stack has cleared, then the functions in the queue are executed.

Web developers use the event loop to create a smoother browsing experience by deciding when to call functions 
and how to handle asynchronous events. 

XHR GET REQUESTS:  We use GET to retrieve data from a source. 

XMLHttpRequest: XMLHttpRequest es un objeto JavaScript. Proporciona una forma fácil de obtener información de 
una URL sin tener que recargar la página completa. Una página web puede actualizar sólo una parte de la página 
sin interrumpir lo que el usuario está haciendo. XMLHttpRequest es ampliamente usado en la programación AJAX.

EJ XHR GET request boilerplate:

const xhr = new XMLHttpRequest();
const url = 'https://api-to-call.com/endpoint';
xhr.responseType = 'json';
xhr.onreadystatechange = () => {
  if (xhr.readyState === XMLHttpRequest.DONE) {
    return xhr.response;
  }
};
xhr.open('GET', url);
xhr.send();

QUERY STRING: On the World Wide Web, a query string is the part of a URL which assigns values to specified 
parameters. The query string commonly includes fields added to a base URL by a Web browser or other client 
application, for example as part of an HTML form.
A query string is separated from the URL using a ? character. After ?, you can then create a parameter which 
is a key value pair joined by a =. 
Examine the example below:

'https://api.datamuse.com/words?key=value'

If you want to add an additional parameter you will have to use the & character to separate your parameters. 
Like so:

'https://api.datamuse.com/words?key=value&anotherKey=anotherValue'

XHR POST REQUESTS: The major difference between a GET request and POST request is that a POST request 
requires additional information to be sent through the request. This additional information is sent in the 
body of the post request.

EJ XHR POST request boilerplate:

const xhr = new XMLHttpRequest();
const url = 'https://api-to-call.com/endpoint';
const data = JSON.stringify({id: '200'});
xhr.responseType = 'json';
xhr.onreadystatechange = () => {
  if(xhr.readyState === XMLHttpRequest.DONE) {
    return xhr.response;
  }
};
xhr.open('POST', url);
xhr.send(data);

-----LECCION 18-----
FETCH() FUNCTION:
* Creates a request object that contains relevant information that an API needs.
* Sends that request object to the API endpoint provided.
* Returns a promise that ultimately resolves to a response object, which contains the status of the promise 
with information the API sent back.

FETCH() GET REQUEST:

fetch('https://api-to-call.com/endpoint').then(response => {
  if (response.ok()) {
    return response.json();
  }
  throw new Error('Request failed!');
}, networkError => {
  console.log(networkError.message);
}).then(jsonResponse => {
  return jsonResponse; 
});

FETCH() POST REQUEST:

fetch('https://api-to-call.com/endpoint', {
  method: 'POST',
  body: JSON.stringify({id: '200'})
}).then(response => {
  if (response.ok()) {
    return response.json();
  }
  throw new Error('Request failed!');
}, networkError => {
  console.log(networkError.message);
}
).then(jsonResponse => {
  return jsonResponse;
});

TRY AND CATCH CODE: In a try...catch statement, code in the try block will be run and in the event of an
exception/error, the code in the catch statement will run.

ASYNC GET REQUEST:

const getData = async () => {
  try {
    const response = await fetch('https://api-to-call.com/endpoint');
    if (response.ok()) {
      const jsonResponse = await response.json();
      return jsonResponse;
    }
    throw new Error('Request failed!');
  } catch(error) {
    console.log(error);
  }
};

ASYNC POST REQUEST:
const getData = async () => {
  try {
    const response = await fetch('https://api-to-call.com/endpoint', {
      method: 'POST',
      body: JSON.stringify({id: '200'})
    });
    if (response.ok()) {
      const jsonResponse = await response.json();
      // Code to execite with jsonResponse
    }
    throw new Error('Request failed!');
  } catch(error) {
    console.log(error);
  }
};
